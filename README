README for the fuzzer written by Ryan Orr, started in January 2014 for testing of ece351 labs.

The fuzzer is a python script designed to be able to accept a language specification, and generate a series of valid or invalid strings for that language.

SPECIFICATION FILE AND SYNTAX
-----------------------------
The fuzzer recognizes languages based on the .lang files within the directory where the script is run. The name of the language is specified by the name of the .lang file (i.e. for language w, the specification file is named w.lang).

The extension for the generated programs may be specified within the .lang file by "@ ext", where ext is the extension for generated programs. For example, w uses .wave files, so the .lang file contains the line "@ wave".

Comments are denoted by beginning the line with '#'. The comment does not have to start at the beginning of the line, as all whitespace is stripped from the start of the line, but partially-commented lines are not supported.

Rules for the language's context free grammar are of the form
	ID => RULE
where ID is the name of the non-terminal and RULE is the implementation for the rule. The '=>' denotes assignment of the rule to that specific id. The initial rule is specified by the id 'Program'. Id's should use the form [a-zA-Z][a-zA-Z0-9_]* but this is currently not actively enforced.

Terminals are denoted by being enclosed within '[]', and can be used to specifiy a string or a range (but not a mixure of both). For example, program only containing the character 'a' is represented by the rule
	Program => [a]
A program generating one random lowercase letter is denoted by the rule
	Program => [a-z]
And a program generating the string "Hello, World!" is generated by the rule
	Program => [Hello World!]
Note that the use of ']' within the terminal string is not currently supported.

Loops are denoted by enclosing '()' and are followed by either '*', to denote zero or more iterations, or by '+" to denote one or more iterations. For example, a program of zero or more 'a's is denoted by the rule
	Program => ([a])*

Concatenation is specified by '-'. For example, a program generating "Hello, World" followed by a series of one or more '!'s is generated by the rule
	Program => [Hello, World]-([!])+

"Or" functionality is denoted by enclosing the options within '{}' and separating the options by '|'. For example, a program containing either one or more 'a's or a single 'b' is created by the rule
	Program => {([a])+|[b]}

General whitespace is represented by '\s'. This randomly selects a character from ' ', '\t', and '\n'. Note '[ ]' may be used to insert spaces or tabs, but not newlines.

Non-terminals are used by specifying the id of the rule to be applied. For example, strings containing an equal number left and right brackets may be generated using the rules
	Program => S
        S => [(]-{S|[]}-[)]
Note that multiple definitions for an id is not supported, as only the first specified rule will be used.


CURRENT FUZZER DESIGN
---------------------



TODO SUMMARY
------------
1. Escape characters
2. Support use of newlines within terminals
3. Refactor specification language for more functionality (see TODO 1,2)
4. Lexical specification and analyzation of the specification language
5. Parsing of the specification language
6. Generate a separate python script to generate strings
7. Specification of multiple rules per id
8. Passing name of .lang file by command line

SUMMARY OF BUGS IN MY ECE351 CODE FOUND BY FUZZER
-------------------------------------------------
lab1: Regex did not consider leading whitespace to the file
